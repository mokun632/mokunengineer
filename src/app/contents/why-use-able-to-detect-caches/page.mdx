## なぜ、useはPromiseのキャッシュ判定ができるのか
  
  

### はじめに
Reactの[ドキュメント](https://ja.react.dev/blog/2024/04/25/react-19#use-does-not-support-promises-created-in-render)に、"レンダー中に作成されたPromiseをサポートしない"と記載されています。
これは今回の記事のタイトルでもある、"なぜ、useはPromiseのキャッシュ判定ができるのか"と多いに関係があり、まずこちらを理解している必要があります。
まず、"レンダー中に作成されたPromiseをサポートしない"とはどういう意味なのか、その理由を説明し、その後に実際のReactのコードを見ながら、なぜ、useはPromiseのキャッシュ判定ができるのかを説明していきます。

### そもそも、レンダー中に作成されたPromiseをサポートしないとは、どういうことか
レンダー中に作成されたPromiseとは、以下のようなコードを指します。
```tsx
import { use } from "react";
 
const fetchData = async () => {
  const response = await fetch("/api/data");
  return response.json();
};
 
const DisplayData = () => {
  const data = use(fetchData());
  return (
    <div>
        <p>{data.title}</p>
        <p>{data.content}</p>
    </div>
  );
};

const App = () => {
  return (
    <Suspense fallback={<div>loading<div>}>
      <DisplayData />
    </Suspense>
  );
};
```
useによって、Promiseがを読み取る場合は、use内でPromiseをThorwするので、Suspenseで包むのが一般的かと思われます。
これは、useというよりSuspenseの仕様になりますが、Suspendの終了時に再度そのコンポーネントの先頭からレンダリングが行われます。  
つまり、この時にuseが再実行され、新しいPromiseが生成され（これがレンダー中に作成されたPromiseになります。）再度Suspendが起き、無限ループが発生します。
これらの無限ループは、React側では特にケアはされません。
これが、"レンダー中に作成されたPromiseをサポートしない"という意味になります。
> [!NOTE]
> useの無限ループが発生した際に、fallbackが再び表示されると思われますが、実際には表示されません。
> Suspend時に、props/stateの変更がなく、Suspendが起きた場合、前回のPromiseを再利用するためです。
> ref: https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md#reading-the-result-of-a-promise-during-a-replay

### どのようにして、Promiseのキャッシュを判定しているのか
さて、前述の通り、useはキャッシュされたPromiseを利用しないと無限ループが発生し、外部APIへのリクエスト等が多発してしまいます。
なので、useは開発環境ではキャッシュされていないPromiseを利用すると以下のような警告が表示されます。
```
Warning: A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.
```
どのようにして、Promiseのキャッシュ判定をして、以下のような警告を表示しているのでしょうか？
いよいよ、実際のReactのコードを見ていきましょう。  
```tsx
function use<T>(usable: Usable<T>): T {
  if (usable !== null && typeof usable === 'object') {
    // $FlowFixMe[method-unbinding]
    if (typeof usable.then === 'function') {
      // This is a thenable.
      const thenable: Thenable<T> = (usable: any);
      return useThenable(thenable);
    } else if (usable.$$typeof === REACT_CONTEXT_TYPE) {
      const context: ReactContext<T> = (usable: any);
      return readContext(context);
    }
  }

  // eslint-disable-next-line react-internal/safe-string-coercion
  throw new Error('An unsupported type was passed to use(): ' + String(usable));
}
```
[ref](https://github.com/facebook/react/blob/8d74e8c73a5cc5e461bb1413a74c6b058c6be134/packages/react-reconciler/src/ReactFiberHooks.js#L1148)
上記が、useの実際のコードです。
useの引数にthenが生えているかどうかで、Promiseかどうかを判定しているようです。
Promiseだった場合は、最初のif文の中に入り、useThenable関数を呼び出しています。

```ts
function useThenable<T>(thenable: Thenable<T>): T {
  // Track the position of the thenable within this fiber.
  const index = thenableIndexCounter;
  thenableIndexCounter += 1;
  if (thenableState === null) {
    thenableState = createThenableState();
  }
  const result = trackUsedThenable(thenableState, thenable, index);
```
[ref](https://github.com/facebook/react/blob/8d74e8c73a5cc5e461bb1413a74c6b058c6be134/packages/react-reconciler/src/ReactFiberHooks.js#L1092)
※ 今回の記事と関係のない箇所は省略しています。
createThenableStateは、単なる配列を返しています。
なぜ、わざわざ空の配列を返すのかは、後述します。
そして、useに渡されたPromise、createThenableStateで作成された配列、そして、indexを引数にして、trackUsedThenableを呼び出しています。
trackUsedThenableにuseのコアロジックが書かれています。

```ts
export function trackUsedThenable<T>(
  thenableState: ThenableState,
  thenable: Thenable<T>,
  index: number,
): T {
  if (__DEV__ && ReactSharedInternals.actQueue !== null) {
    ReactSharedInternals.didUsePromise = true;
  }
  const trackedThenables = getThenablesFromState(thenableState);
  const previous = trackedThenables[index];
  if (previous === undefined) {
    trackedThenables.push(thenable);
  } else {
    if (previous !== thenable) {
      // Reuse the previous thenable, and drop the new one. We can assume
      // they represent the same value, because components are idempotent.

      if (__DEV__) {
        const thenableStateDev: ThenableStateDev = (thenableState: any);
        if (!thenableStateDev.didWarnAboutUncachedPromise) {
          // We should only warn the first time an uncached thenable is
          // discovered per component, because if there are multiple, the
          // subsequent ones are likely derived from the first.
          //
          // We track this on the thenableState instead of deduping using the
          // component name like we usually do, because in the case of a
          // promise-as-React-node, the owner component is likely different from
          // the parent that's currently being reconciled. We'd have to track
          // the owner using state, which we're trying to move away from. Though
          // since this is dev-only, maybe that'd be OK.
          //
          // However, another benefit of doing it this way is we might
          // eventually have a thenableState per memo/Forget boundary instead
          // of per component, so this would allow us to have more
          // granular warnings.
          thenableStateDev.didWarnAboutUncachedPromise = true;

          // TODO: This warning should link to a corresponding docs page.
          console.error(
            'A component was suspended by an uncached promise. Creating ' +
              'promises inside a Client Component or hook is not yet ' +
              'supported, except via a Suspense-compatible library or framework.',
          );
        }
      }

      // Avoid an unhandled rejection errors for the Promises that we'll
      // intentionally ignore.
      thenable.then(noop, noop);
      thenable = previous;
    }
  }
```
[ref](https://github.com/facebook/react/blob/68dbd84b61cc2504c30e19f748f59a52d331f851/packages/react-server/src/ReactFlightThenable.js#L45)
※ 今回の記事と関係のない箇所は省略しています。
結論から先に言うと、上記else文内のif文のprevious !== thenableがPromiseのキャッシュ判定をしている箇所です。
このif文に入ると、console.errorで警告が表示されます。
順番に追ってみていきましょう。
まず、getThenablesFromStateでは、そのまま配列を返しています。
これをindexで取り出し、previousに代入して、previousがundefinedだった場合は、trackedThenablesにthenableをpushしています。
初回レンダリング時には、previousはundefinedになるので、trackedThenablesにthenableがpushされます。
問題は、elseの中です。
先ほど、言ったように、初回レンダリング時には、previousはundefinedになるので、elseの中には入りません。
elseの中に入るのは、2回目以降のレンダリング時です。
ですが、初回レンダリング時でもキャッシュされていないPromiseが渡された場合は、警告が表示されます。
なぜ、初回レンダリング時でも警告が表示されるのでしょうか？
答えは、Strict Modeです。
Strict Modeにより、コンポーネントが2回実行され、trackedThenablesにthenableがある状態で、useが再実行されるので、elseの中に入ります。
その時に、previousとthenableが異なる場合は、警告が表示されます。
createThenableStateで空の配列を返す理由は、Promiseをtrackingして、同じPromiseなのか比較するためなんですね。

### まとめ
結論、useはStrict Modeで2回実行される事を利用して、1回目と2回目のPromiseを比較して、異なるPromiseだった場合に警告を表示しています。
こういった事も見越して、Strict Modeが導入されたんですかね。
天才的な設計力ですね。
